# 🚗 미션 - 다리 건너기


## 👀 문제 확인하기
- 우아한테크코스 4주차 과제 '**다리 건너기**'의 구현 기능과 구현 로직을 담은 문서입니다.
- 문제는 [여기](https://github.com/woowacourse-precourse/java-bridge)에서 확인해 주세요.

---

## 🌟 구현 기능 목록

### [☑️] 사용자 입력 기능
- 사용자로부터 값을 입력받는다.
  - *InputView#readBridgeLength()*

### [☑️] 콘솔 출력 기능
- 게임 진행에 필요한 안내 멘트를 출력한다.
  - `다리 건너기 게임을 시작합니다.`
    - *OutputView#printStartMessage()*
  - `다리의 길이를 입력해주세요.`
    - *OutputView#printBridgeLengthMessage()*

- 사용자가 이동할 칸에 대한 안내 멘트를 출력한다.
  - `이동할 칸을 선택해주세요. (위: U, 아래: D)`
    - *OutputView#printPlayerMoveMessage()*

- 게임 종료에 대한 안내 멘트를 출력한다.
  - `게임을 다시 시도할지 여부를 입력해주세요. (재시도: R, 종료: Q)`
    - *OutputView#printPlayControlMessage()*

- 다리의 상태를 출력한다.
  - 사용자가 입력한 값과 건널 수 있는 다리인지에 따라 다리 맵을 출력한다.
    - *OutputView#printMap()*

- 게임의 최종 결과 및 성공 여부를 출력한다.
  - `최종 게임 결과` 멘트와 함께 최종적으로 다리 맵을 출력한다.
  - `게임 성공 여부: (성공/실패)` 및 `총 시도한 횟수: x`를 출력한다.
    - *OutputView#getGameResult()*

### [☑️] 제한사항 검증 기능
- 사용자가 입력한 값에 대한 검증 기능을 제공한다. 다음과 같은 경우 예외 사항으로 판단한다.
  - [예외] 입력받은 다리의 길이가 숫자인지 검증한다.☑️
    - *ValidationUtil#checkNumberType()*
  - [예외] 입력받은 다리의 길이가 3~20 사이의 값을 가지는지 검증한다.
    - *ValidationUtil#checkNumberRange()*
  - [예외] 입력받은 플레이어가 이동할 칸이 U 혹은 D인지 검증한다.
    - *ValidationUtil#validatePlayerMoveInput()*
  - [예외] 입력받은 재시작/종료 여부가 R 혹은 Q인지 검증한다. 
    - *ValidationUtil#validatePlayControlInput()*
- 예외 사항에 대해서는 `IllegalArgumentException`을 발생시킨다.

### [☑️] 다리에 대한 랜덤 숫자 부여 기능
- 0과 1 중 랜덤으로 값을 생성한 뒤, 해당 값에 따라 건널 수 있는 칸에 대해 U 혹은 D로 정의한다.
  - *BridgeMaker#makeBridge()*

### [☑️] 사용자의 움직임 확인 기능
- 사용자가 있는 위치의 다리를 체크하여 사용자가 건널 수 있는 다리를 선택했는지 체크한다.
- 건널 수 있다면 사용자의 위치를 이동하고, 성공 플래그를 true로 세팅한다. 
- 건널 수 없다면 성공 플래그를 false로 설정한다.
  - *BridgePlayer#checkMove()*

### [☑️] 게임 재시작 기능
- 사용자가 게임을 재시작하면 시도 횟수를 증가시키고 재시작 플래그를 설정한다.
  - *BridgeGame#retry()*

### [☑️] 게임 진행 확인 기능
- 사용자의 위치가 다리의 끝이 아닌지 체크한다.
  - *BridgeGame#isNotGameEnd()*

### [☑️] 재시작한 게임에 대한 판단 기능
- 재시작한 게임의 결과를 확인하고, 성공했다면 재시작 플래그를 다시 false로 변경한다.
  - *BridgeGame#checkRetryGameResult()*

---

## 💡 구현 로직
~~~
1. 시작 메시지 출력 후, 사용자에게 다리의 길이를 입력받는다.
  1-1. 올바르지 않은 입력이 들어올 경우 다시 입력받는다.
  
2. 입력받은 다리의 길이를 바탕으로 건널 수 있는 다리의 칸을 정한다.

3. 게임이 종료되기 전까지 계속 반복한다.
  3-1. 사용자에게 이동할 칸을 입력받은 다음, 건널 수 있는 칸인지 체크하고 맵을 출력한다.
    3-1-1. 잘못된 입력에 대해서는 재입력을 받는다.
  3-2. 만약 이동할 칸이 건널 수 있는 다리라면 다시 3번을 반복한다.
  3-3. 건널 수 없는 다리라면 재시도 / 종료에 대한 입력을 받는다.
    3-3-1. 잘못된 입력에 대해서는 재입력을 받는다.
  3-4. 사용자가 종료를 입력했을 경우 즉시 종료한다. 
  3-5. 사용자가 재시도를 입력했을 경우 재시도 플래그를 true로 세팅하고 이전의 다리 맵 결과를 제거한다.
    3-5-1. 만약 재시도한 케이스에서 성공했다면 재시도에 대한 정보를 false로 변경한다.

4. 게임 종료 후 최종 다리 맵의 상태와 성공 여부, 총 시도한 횟수를 출력한다.
~~~

---

## 🔍 소감
- 최종 과제인 만큼 지켜야 할 명세도 많고 고민했던 점도 많았던 과제였습니다.

### 😃 MVC 구조 활용하기 
- 이번 과제는 명시적으로 view가 주어졌기 때문에 MVC 구조로 풀어나가야 된다는 생각이 들었습니다. 
- inputView와 outputView로 명시적으로 나누어져 있던 덕분에 설계 시에 해야 되는 일을 명확하게 구분할 수 있었습니다.
기존 과제 진행 시에는 messageUtil을 통해 진행하였던 화면 출력을, outputView를 통해 처리하다 보니 한 가지 역할에 대해 분명하게 나타내고 처리할 수 있었다는 점을 느낄 수 있었으며,
MVC 구조를 사용하는 이유에 대해서 와닿을 수 있었던 과제였던 것 같습니다.
- 또한, 도메인 분리 시 게임을 진행하는 플레이어에 대해 BridgePlay 클래스를 생성하였습니다. 초기 설계 시에는 이를 분리하지 않고, BridgeGame 클래스 내에서 처리하였으나
게임을 시도한 횟수나 게임의 성공 여부, 그리고 사용자가 입력한 명령어는 '사용자의 행위'로부터 이루어지기 때문에 플레이어를 따로 나눠야 된다고 생각했습니다. 

### 😎객체에게 질문을 던져라!
- 3주차 과제 피드백 중, `'객체는 객체스럽게 사용하라'`는 것을 보고, 이번 과제에서는 get-set 구조를 최대한 덜어내려 노력했습니다.
- 지난 로또 과제에서는 피드백에서 나왔던 예제처럼 로또 클래스를 활용하지 않고, 오직 로또 클래스에서 getter를 통해 값을 가져오고, 이에 대한 검증이나 세부 로직은
메인 서비스에서 진행했었습니다. 그래서 이번 과제에서는, inputView에서 값을 입력받을 때 validation 로직을 함께 진행한 결과를 가져오고,
BridgePlayer 클래스에서 저장해두었던 사용자의 입력과 사용자의 현재 위치에서의 다리 상태에 대한 비교 로직을 설계하였습니다. (checkMove())
- 덕분에, 외부에서 사용자의 입력값과 현재 위치값을 가져와서 하지 않고, 객체에게 질문하듯이 넘기며 객체스럽게 사용할 수 있었던 것 같습니다.
- 추가적으로, 객체에게 질문을 던지게 되면 메인 로직이 비교적 가벼워지기 때문에 이번 주차 제한사항인 메서드 길이에 대한 제한사항도 지킬 수 있었던 것 같습니다.

### 🧐Enum 활용하기
- 지난 주차 과제에서는 ErrorMessage에 대해서 외부에서 설정한 값을 넣어주어야 했기 때문에 static final class로 구현하였으나, 이 부분을 enum으로 수정하였습니다.
  - System.out.prinf와 String.format을 활용하여 메시지에 값을 던짐으로서 이 부분에 대해 해결할 수 있어서 뿌듯했습니다.
- 또한, enum 클래스를 조금 더 세분화하여 구성하였습니다. 지난 주차에서는 로또 번호에 대해서 한 번에 관리하였지만, 
이번 주차 과제에서는 다리 맵을 출력하기 위한 상수, 사용자 제어를 위한 상수, 사용자 이동을 위한 상수, 범위를 위한 상수로 나누었습니다. 
  - 특히, 이동의 경우 위/아래를 U, D 외에 1, 0로도 표현할 수 있기 때문에 enum 클래스를 더 용이하게 활용할 수 있었던 것 같습니다.

### 🥺테스트 어노테이션 활용하기
- 지난 주차 소감문에서 작성했던 점 중 하나인 테스트 보조 어노테이션을 활용하였습니다.
  - 입력에 대한 검증 로직을 테스트하는 부분에서 다양한 예외 케이스를 활용하기 위해 @ParameterizedTest와 @ValueSource를 활용하였습니다. 
덕분에 중복되는 테스트 코드를 막고 깔끔한 테스트 코드를 가져갈 수 있었던 것 같습니다. 
또한, 하나의 테스트 코드에서 여러 개의 assert 로직을 사용할 때 분리하기 위해, as를 통해 짤막한 description을 작성하였습니다. 
- 또한, private 접근자에 대한 테스트는 진행하지 않았습니다. private 메서드는 결국 public 메서드에서 호출하여 테스트를 진행할 수 있기 때문에
예외 케이스를 여러 개 두어서 각 상황에 맞는 예외 메시지가 터트려지는지 확인을 진행하였습니다.