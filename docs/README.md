# 4주차 미션 - 다리 건너기

## 게임 개요
오징어 게임에 나온 다리 건너기 게임을 구현하는 미션이다.
사용자는 어느 칸이 건널 수 있는 칸인지 모르는 상태에서 윗칸과 아래칸 중 하나를 선택한다.
건널 수 있는 칸을 선택 시 다음 칸을 선택할 수 있고, 건너지 못하는 칸을 선택 시에는 라운드가 종료된다.
이후, 게임의 재시작 여부를 선택할 수 있다.
다리를 끝까지 건넌다면 성공!

## 프로젝트 구조(작성할 것!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)

## 기능 구현 목록 정리
### 도메인 로직
- [x] 다리 길이가 3부터 20까지인지 유효성 검증을 한다.
  - [x] 다리 길이가 2 혹은 21인 경우를 검증한다.
  - [x] 다리 길이가 3 혹은 20인 경우를 검증한다.
- [x] 다리를 생성한다.
  - [x] 다리를 생성할 때 위 칸과 아래 칸 중 건널 수 있는 칸은 0과 1 중 무작위 값을 이용해서 정한다.
  - [x] 위 칸을 건널 수 있는 경우 U, 아래 칸을 건널 수 있는 경우 D값으로 나타낸다.
  - [x] 무작위 값이 0인 경우 아래 칸, 1인 경우 위 칸이 건널 수 있는 칸이 된다.
- 사용자가 입력한 이동할 칸에 대해 결과를 낸다.
- [x] 결과에 따라 출력할 다리 모양을 만든다.
  - [x] 이동할 수 있는 칸을 선택한 경우 O 표시
  - [x] 이동할 수 없는 칸을 선택한 경우 X 표시
  - [x] 선택하지 않은 칸은 공백 한 칸으로 표시
  - [x] 다리의 시작은 [, 다리의 끝은 ]으로 표시
  - [x] 다리 칸의 구분은 | (앞뒤 공백 포함) 문자열로 구분
  - [x] 현재까지 건넌 다리를 모두 출력
- [x] 건널 수 있는 칸을 선택한 경우
  - [x] 과정을 반복한다.
- [x] 건널 수 없는 칸을 선택한 경우
  - [x] 라운드를 종료한다.
- [x] 게임의 상태를 정한다.
  - [x] 끝까지 간 경우 성공
  - [x] 끝까지 가지 못한 경우 실패
- [x] 재시작 여부가 "Q"가 아니라면 같은 다리에 대해 과정을 반복한다.
- [x] 총 시도한 횟수를 계산한다.

### 어플리케이션 서비스 로직
- [x] 게임 시작 안내를 출력한다.
- [x] 다리 길이의 입력을 안내한다.
- [x] 다리 길이를 입력 받는다.
    - [x] 다리 길이가 숫자인지 유효성 검증을 한다.
- [x] 이동할 칸의 입력을 안내한다.
- [x] 이동할 칸을 입력 받는다.
    - [x] "U"와 "D"인지 유효성 검증을 한다.
- [x] 이동의 결과를 안내한다.
- [x] 게임을 다시 시도할지 여부를 입력 받는다.
  - [x] "R"과 "Q"인지 유효성 검증을 한다.
- [x] 최종 게임 결과를 안내한다. 
- [x] 게임 성공 여부를 안내한다.
- [x] 총 시도한 횟수를 안내받는다.

## 게임 진행 과정

1. 게임 시작 안내를 출력한다.
2. 다리의 길이를 입력한다.
   - 다리 길이는 3부터 20까지의 숫자이다.
   - 숫자가 아닌 입력 예외 처리
   - 숫자이지만 범위가 다른 예외 처리
3. 다리를 생성한다.
   - 다리를 생성할 때 위 칸과 아래 칸 중 건널 수 있는 칸은 0과 1 중 무작위 값을 이용해서 정한다.
   - 위 칸을 건널 수 있는 경우 U, 아래 칸을 건널 수 있는 경우 D값으로 나타낸다.
   - 무작위 값이 0인 경우 아래 칸, 1인 경우 위 칸이 건널 수 있는 칸이 된다.
4. 이동할 칸을 입력한다.
   - "U"와 "D"로 위와 아래를 선택한다.
   - 나머지 입력은 예외처리한다.
5. 이동의 결과를 안내받는다.
   - 이동할 수 있는 칸을 선택한 경우 O 표시
   - 이동할 수 없는 칸을 선택한 경우 X 표시
   - 선택하지 않은 칸은 공백 한 칸으로 표시
   - 다리의 시작은 [, 다리의 끝은 ]으로 표시
   - 다리 칸의 구분은 | (앞뒤 공백 포함) 문자열로 구분
   - 현재까지 건넌 다리를 모두 출력
6. 1. 건널 수 있는 칸을 선택한 경우
        - 다리를 다 건너지 않은 경우, 다음 칸에 대하여 4.-5.의 과정을 반복한다.
        - 다리를 다 건넌 경우, 7.을 진행한다.
   2. 건널 수 없는 칸을 선택한 경우
        - 라운드를 종료한다. 
        - 게임을 다시 시도할지 여부를 입력받는다.
            - "R"과 "Q"로 각각 재시작, 종료를 선택한다.
            - "R"을 선택할 시, 4.의 과정부터 다시 시작한다.
            - 다리는 같은 다리에 대하여 진행한다.
7. 게임 성공 여부를 안내받는다.
8. 총 시도한 횟수를 안내받는다.

## 주요 요구 사항

- 사용자가 잘못된 값을 입력할 경우 IllegalArgumentException를 발생시키고, "[ERROR]"로 시작하는 에러 메시지를 출력 후 그 부분부터 입력을 다시 받는다. 
- Exception이 아닌 IllegalArgumentException, IllegalStateException 등과 같은 명확한 유형을 처리한다.
- 프로그래밍 요구 사항에서 달리 명시하지 않는 한 파일, 패키지 이름을 수정하거나 이동하지 않는다.
- indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
- 도메인 로직에 단위 테스트를 구현해야 한다. 단, UI(System.out, System.in, Scanner) 로직은 제외한다.
- 메서드의 파라미터 개수는 최대 3개까지만 허용한다.
- 함수(또는 메서드)의 길이가 10라인을 넘어가지 않도록 구현한다.
- InputView
  - 패키지 변경 가능 
  - 메서드 시그니처와 반환 타입 변경 가능
  - 메서드 추가 가능
  - InputView 클래스에서만 camp.nextstep.edu.missionutils.Console 의 readLine() 메서드를 이용해 사용자의 입력을 받을 수 있다.
- OutputView
  - 패키지 변경 가능
  - **메서드 이름 변경 불가**
  - 파라미터, 반환 타입 추가 변경 가능
  - 메서드 추가 가능
- BridgeGame
  - 필드 추가 가능
  - 패키지 변경 가능
  - **메서드 이름 변경 불가**
  - 파라미터, 반환 타입 추가 변경 가능
  - 메서드 추가, 변경 가능
- BridgeMaker
  - **필드 변경 불가**
  - **메서드 시그니처 반환 타입 변경 불가**
- BridgeRandomNumberGenerator
  - Random 값 추출은 제공된 bridge.BridgeRandomNumberGenerator의 generate()를 활용
  - **BridgeRandomNumberGenerator, BridgeNumberGenerator 클래스의 코드는 변경 불가**


## 체크리스트

[] 요구사항을 정확히 준수하였는가?
[] 추가적인 예외를 고려하였는가?
[] 메소드가 하나의 기능만 하는가?
[] 한 메소드에 오직 한 단계의 인덴트만 허용했는가?
[] 메소드 10줄 안 넘는가?
[] else 쓰지 않았는가?
[] 원시값과 문자열 포장했는가?
[] 콜렉션에 대해 일급 콜렉션을 적용했는가?
[] 3개 이상의 인스턴스 변수를 가진 클래스를 구현하지는 않았는가?
[] 메소드 이름이 적절한가? 동사와 전치사로 시작하는가?
[] 변수의 이름이 적절한가? 명사인가?
[] 메소드와 변수의 이름을 축약하지는 않았는가? 중복하지는 않았는가?
[] 커밋 메시지가 적절한가? 의미는 명확한가?
[] 매직넘버를 상수로 선언했는가?
[] getter/setter가 없이 구현했는가?
[] 하나의 소스 파일에 하나의 클래스만 있는가?
[] 클래스를 작게 유지하기 위해 노력했는가?
[] import에 와일드 카드(*)가 없는가?
[] 패키지 선언 후와 메소드들의 사이에 빈 줄을 넣었는가?
[] 공백도 컨벤션을 준수했는가? 공백 라인을 의미있게 사용했는가?
[] 의미 없는 주석은 없는가?
[] Java가 제공하는 API를 적극 활용했는가?
[] 배열 대신 Java Collection을 사용했는가?
[] 정리한 기능 목록마다 정상 동작함을 테스트 코드로 확인하였는가?
[] PR 이름 제대로 했는가?
[] 출력 형식 제대로 했는가?
[] 불필요한 멤버 변수는 없는가?
[] 테스트코드의 리팩터링을 했는가?
[] 파라미터의 값만 바뀌는 테스트코드에서 @valueSource를 사용했는가?
[] final 값을 적절히 사용했는가?
[] 인스턴스 변수의 접근 제한을 private으로 했는가?
[] 단위테스트하기 어려운 코드를 적절히 리팩터링 했는가?
[] view가 domain을 모르는가?
[] domain이 view를 모르는가?
[] controller와 service가 dto를 통해 값을 주고 받는가?
[] service가 view를 모르는가?

## 리펙터링 완료 클래스 체크
- Application
- Bridge
- BridgeGame
- BridgeMaker
- [x] BridgeNumberGenerator
- [x] BridgeRandomNumberGenerator
- BridgeSize
- [x] MapRenderer
- [x] Cell
- [x] Constant
- GameController
- [x] Validator
- [x] InputView
- [x] OutputView
- [X] ViewConstant

- ApplicationTest
- BridgeGameTest
- BridgeMakerTest
- BridgeSizeTest
- BridgeTest
- MapRendererTest
- ValidatorTest