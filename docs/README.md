## 4주차 학습 목표
클래스(객체)를 분리하는 연습
리팩터링


## 클래스 정보
BridgeGame : 다리 건너기 게임을 관리하는 클래스
BridgeMaker : 다리의 길이를 입력 받아서 다리를 생성해주는 역할을 한다
InputView : 사용자로부터 입력을 받는 역할을 한다
OutputView : 사용자에게 게임 진행 상황과 결과를 출력하는 역할을 한다
BridgeNumberGenerator : 0혹은 1의 값을 생성한다
--
MoveResult : 이동 결과에 대한 enum 정의
BridgeType : 다리 위치에 대한 enum 정의
--
Bridge : 객체스러운 List<String>


## 기능 구현 설계  
- [ ] 다리 길이를 입력받는다  
  - [ ] 길이를 숫자로 파싱하고 실패하면 `IllegalArgumentException`을 발생시킨다
  - [ ] 3이상 20 이하의 숫자가 아니라면 `IllegalArgumentException`을 발생시킨다
- [ ] 다리 길이를 입력받고 생성한다
  - [ ] 0 ~ 1의 수를 랜덤 생성해 생성한 수가 0이라면 D, 1이라면 U를 입력한다
- [ ] 플레이어에게서 이동할 칸을 입력받는다
  - [ ] U 혹은 D의 값이 아니라면 `IllegalArgumentException`을 발생시킨다
  - [ ] 플레이어에게 입력받은 값이 U라면 위 다리, D라면 아래 다리로 이동한다
    - [ ] 실패한다면 6으로 넘어간다
- [ ] 게임 진행 현황을 플레이어에게 보여준다
  - [ ] 이동할 수 있는 칸을 선택한 경우 O 표시한다
  - [ ] 이동할 수 없는 칸을 선택한 경우 X 표시한다
  - [ ] 다리의 시작은 `[`, 다리의 끝은 `]`으로 표시한다
  - [ ] 다리 칸의 구분은 `|`(앞뒤 공백 포함) 문자열로 구분한다
  - [ ] 현재까지 건넌 다리를 모두 출력한다
- [ ] 3 ~ 4를 반복하다 다리 길이만큼 성공했다면 게임은 종료된다
- [ ] 플레이어에게 재시작할지 묻는다
  - [ ] 플레이어가 R을 입력하면 재시작, Q를 입력하면 애플리케이션을 종료한다
  - [ ] R 혹은 Q가 아니라면 `IllegalArgumentException`을 발생시킨다
- [ ] 최종 게임 결과를 플레이어에게 보여준다
- [ ] 게임을 재시작하거나 애플리케이션을 종료한다

## 추가 요구 사항
- 함수(또는 메서드)의 길이가 10라인을 넘어가지 않도록 구현한다
- 메서드의 파라미터 개수는 최대 3개까지만 허용한다
- `InputView`
  - `InputView`의 메서드의 시그니처(인자, 이름)와 반환 타입은 변경할 수 있다
  - 사용자 값 입력을 위해 필요한 메서드를 추가할 수 있다
- `OutputView`
  - `OutputView`의 메서드의 이름은 변경할 수 없고, 인자와 반환 타입은 필요에 따라 추가하거나 변경할 수 있다
  - 값 출력을 위해 필요한 메서드를 추가할 수 있다
- `BridgeGame`
  - `BridgeGame`에 필드(인스턴스 변수)를 추가할 수 있다
  - `BridgeGame`의 메서드의 이름은 변경할 수 없고, 인자와 반환 타입은 필요에 따라 추가하거나 변경할 수 있다
  - 게임 진행을 위해 필요한 메서드를 추가 하거나 변경할 수 있다
- `BridgeMaker`
  - `BridgeMaker`의 필드(인스턴스 변수)를 변경할 수 없다
  - `BridgeMaker`의 메서드의 시그니처(인자, 이름)와 반환 타입은 변경할 수 없다
- `BridgeRandomNumberGenerator`
  - Random 값 추출은 제공된 `bridge.BridgeRandomNumberGenerator`의 `generate()`를 활용한다
  - `BridgeRandomNumberGenerator`, `BridgeNumberGenerator` 클래스의 코드는 변경할 수 없다


## 3주차 피드 요약
- 함수(메서드) 라인에 대한 기준
- 발생할 수 있는 예외 상황에 대해 고민한다
- 비즈니스 로직과 UI 로직을 분리한다
- 연관성이 있는 상수는 static final 대신 enum을 활용한다
- final 키워드를 사용해 값의 변경을 막는다
- 객체의 상태 접근을 제한한다
- 객체는 객체스럽게 사용한다
- 필드(인스턴스 변수)의 수를 줄이기 위해 노력한다
- 성공하는 케이스 뿐만 아니라 예외에 대한 케이스도 테스트한다
- 테스트 코드도 코드다
- 테스트하기 어려운 요소들을 클래스 외부로 옮긴다
- private 함수를 테스트 하고 싶다면 클래스(객체) 분리를 고려한다
