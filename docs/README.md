


## 🔍 기능 요구 사항 분석

- 한 차례에서 위, 아래 중 하나의 다리만 골라 건널 수 있다.
- 다리 길이는 사용자에게 입력 받는다. 즉 다리 길이 == 게임의 총 차례 수
- 사용자가 입력한 다리 길이를 가지고 같은 위치의 위, 아래 다리 중 건널 수 있는 다리를 무작위로 고른 다리를 만든다.
- 다리가 생성되면 사용자는 위,아래 중 건널 다리를 선택한다.
- 사용자가 선택한 다리가 건널 수 있으면 다음 다리를 선택하도록 한다.
- 사용자가 선택한 다리가 건널 수 없으면 게임을 재시작 할지, 종료할지를 선택하도록 한다.
- 만약 재시작을 선택한다면 처음 만든 다리 그대로 사용하고 (다리 길이도 다시 입력받지 않음.) 다시 처음부터 다리를 건너도록 한다.
- 만약 틀렸을 때, 종료를 선택한다면, 게임 성공 여부를 실패로 출력하고, 시도 횟수를 표시한다.
    - 여기서 시도 횟수는 처음 시도한 횟수(1) + 게임을 재시작한 횟수를 말한다.
- 사용자가 잘못된 값을 입력할 경우 예외 메세지를 띄우고 해당 값을 다시 입력 받는다.


## 🚦 기능 요구 사항 목록

+ [x] 게임 시작 멘트 출력
+ [x] 다리 길이 입력 받기
+ [x] 입력된 다리 길이 값 유효성 검사
+ [x] 다리 길이 만큼의 다리를 생성한다.
+ [x] 사용자에게 이동할 칸을 U,D로 입력 받는다.
+ [x] 입력된 값을 유효성 검사
+ [x] 이동할 칸이 건널 수 있는 다리인지 검사 한다.
+ [x] 이동 상태를 O과 X로 표시하여 출력한다.
    + [x] 건널 수 있다면 다음 칸의 이동할 칸을 입력받는다.
    + [x] 건널 수 없다면 게임을 종료할지 재시작할지를 물어 본다.
        + [x] 시도 횟수를 카운트 한다.
        + [x] R을 입력 받는다면 게임을 재시작한다.
        + [x] Q를 입력 받는다면 게임을 종료한다.
            + [x] 게임 성공 여부와 총 시도 횟수를 출력한다.
+ [x] 마지막 칸 까지 통과하면 게임 성공 여부: 성공과 총 시도 횟수를 출력한다.


## 예외 처리 목록
+ [x] 입력된 값이 유효하지 않으면 예외 발생
+ [x] 다시 값을 입력하도록 한다.

<br/>
<hr/>

## 🌊 추가된 프로그래밍 요구 사항

+ [x] 메서드의 길이가 10라인을 넘어가지 않도록 구현한다.
+ [x] 메서드의 파라미터 개수를 최대 3개 까지만 쓴다.
+ [x] 기존에 생성 되어있는 클래스를 요구사항을 참고하여 구현하여 사용한다.


### InputView 클래스

- InputView의 시그니처(인자, 이름)와 반환 타입은 변경 가능
- 사용자 값 입력을 위해 필요한 추가 메서드 구현 가능
- camp.nextstep.edu.missionutils.Console의 readLine()을 활용

### OutputView 클래스

- 메서드 이름은 변경 불가
- 인자와 반환 타입은 필요에 따라 추가,변경 가능


### BridgeGame 클래스

- 필드 추가 가능
- 메서드 이름 변경 불가
- 인자와 반환 타입은 필요에 따라 추가,변경 가능
- 게임 진행을 위해 필요한 메서드를 추가 하거나 변경 가능

### BridgeMaker 클래스

- 필드 변경 불가
- 메서드 시그니처,반환타입 변경 불가

### BridgeRandomNumberGenerator 클래스

- Random 값 추출은 제공된 bridge.BridgeRandomNumberGenerator의 generate()를 활용
- BridgeRandomNumberGenerator, BridgeNumberGenerator 클래스의 코드는 변경할 수 없음


<hr/>

## 🚀 3주차 피드백 반영

### 메서드 라인 기준
+ [x] 라인 길이 제한은 main함수에도 해당 된다. 
+ [x] 공백도 라인 길이에 포함한다.

### 예외상황을 좀 더 꼼꼼히 살피고 프로그래밍 한다.
+ [x] 사용자 입력값 형식이 올바른지 뿐만 아니라, 프로그램의 전체적인 맥락에서 올바른 값인지 또한 고려해 본다.

### 비즈니스 로직과 UI 로직을 분리
+ [x] 현재 객체 상태를 보기 위한 UI로직이라면 toString()을 통해 구현한다.
+ [ ] View에서 사용할 데이터라면 getter 메서드를 통해 데이터를 전달한다.

### 연관성이 있는 상수는 static final 대신 enum을 활용한다
+ [ ] enum으로 묶을 상수들를 고려한다.

### final 키워드를 사용해 값의 변경을 막는다
- 이전 로또 과제에서 입력받은 금액등은 변경을 제한해야 하는 값이다.
+ [x] 이번 과제에서도 변경을 막아야 할 변수를 생각해 보자.

### 객체의 상태 접근을 제한한다
+ [x] 인스턴스 변수의 접근 제어자는 private로 구현

### 객체는 객체스럽게 사용
+ [x] getter로 데이터를 꺼내서 다른 클래스에서 처리하도록 하지 말고, 데이터를 가지는 객체가 일하도록 한다.
+ [x] getter를 사용하는 대신 객체에 메시지를 보내자

### 필드(인스턴스 변수)의 수를 줄이기 위해 노력한다
- 필드가 많으면 객체 복잡도가 높아지고, 버그 발생 가능성을 높일 수 있다.
+ [x] 꼭 필요한 필드인지 생각하기


### 예외에 대한 테스트 케이스도 작성한다.
+ [x] 결함이 자주 발생하는 부분이 경계값이므로 이 부분을 꼼꼼히 확인한다.

### 테스트 코드도 리팩토링을 통해 개선해 나가자
+ [ ] 테스트 코드를 리팩토링 하자.
+ [x] 중복되는 부분은 @ParameterizedTest를 통해 일괄 처리할 수 있다.

### 테스트를 위한 코드는 구현 코드에서 분리되어야 한다.
+ [x] 테스트 통과를 위해 구현 코드를 변경하지 말아야 한다.
+ [x] 테스트에서만 사용되는 로직은 구현 코드에 구현하지 않는다.
+ [x] 테스트를 위해 구현 코드의 접근자를 변경하지 않는다.

### 단위 테스트하기 어려운 코드를 단위 테스트하기
+ [x] 단위 테스트하기 어렵다면, 어려운 부분을 분리하여 테스트 가능한 부분을 단위 테스트 하기
+ [ ] 분리한 부분은 어떻게 테스트하기 쉽게 바꿀 수 있을지 고민해 보기.

### private 함수를 테스트 하고 싶다면 클래스(객체) 분리를 고려한다
- 가독성을 위한 public 메서드 내의 로직을 private 메서드로 분리한 경우 자동으로 private 메서드 또한 테스트 범위에 포함 되지만 그렇지 않은 경우는 테스트하는데 어려움이 있다.
+ [ ] 이러한 private 메서드가 있으면 리팩토링 할 때, 클래스 분리를 고려해 본다.