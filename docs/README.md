# 4주차 미션 - 다리 건너기

## 게임 개요

오징어 게임에 나온 다리 건너기 게임을 구현하는 미션이다.</br>
사용자는 어느 칸이 건널 수 있는 칸인지 모르는 상태에서 윗칸과 아래칸 중 하나를 선택한다.</br>
건널 수 있는 칸을 선택 시 다음 칸을 선택할 수 있고, 건너지 못하는 칸을 선택 시에는 라운드가 종료된다.</br>
이후, 게임의 재시작 여부를 선택할 수 있다.</br>
다리를 끝까지 건넌다면 성공!

## 프로젝트 구조

└── src</br>
├── main</br>
│ └── java</br>
│ ├── bridge : 다리 건너기 게임의 domain </br>
│ │ ├── Application.java : 프로그램을 실행하는 클래스</br>
│ │ ├── Bridge.java : 다리 모양을 저장하고 검증하는 클래스</br>
│ │ ├── BridgeMaker.java : 다리를 만드는 클래스</br>
│ │ ├── BridgeNumberGenerator.java : 숫자를 생성하는 인터페이스</br>
│ │ ├── BridgeRandomNumberGenerator.java : 0과 1 중 랜덤하게 반환하는 클래스</br>
│ │ ├── BridgeSize.java : 다리의 길이를 저장하고 검증하는 클래스</br>
│ │ ├── GameCommand.java : 게임 재시작 여부를 저장하고 검증하는 클래스</br>
│ │ ├── MoveResult.java : 이동의 결과인 지도, 맞은 이동의 횟수, 성공 여부를 구하는 클래스</br>
│ │ ├── Moving.java : 사용자의 이동에 대한 입력을 저장하고 검증하는 클래스</br>
│ │ ├── MovingStack.java : 사용자의 입력들을 차례대로 저장하는 클래스</br>
│ │ └── PlayCount.java : 사용자의 총 게임 횟수를 저장하는 클래스</br>
│ ├── bridgeConstant</br>
│ │ ├── Cell.java : 윗칸과 아랫칸에 대한 상수값을 가지고 있는 enum</br>
│ │ ├── Constant.java : 다리 건너기 게임에서 반복적으로 쓰이는 숫자와 문자열을 상수로 선언한 클래스</br>
│ │ └── ErrorLog.java : 출력할 에러메세지들을 모아놓은 enum</br>
│ ├── controller</br>
│ │ └── GameController.java : view와 model 사이에서 dto를 넘겨주고 진행을 관리하는 클래스</br>
│ ├── dto</br>
│ │ ├── BridgeResponseDto.java : 만든 다리를 전달하는 dto</br>
│ │ ├── BridgeSizeRequestDto.java : 사용자가 입력한 다리 길이를 전달하는 dto</br>
│ │ ├── GameCommandRequestDto.java : 사용자가 입력한 재시작 여부를 전달하는 dto</br>
│ │ ├── MoveResultResponseDto.java : 이동에 대한 결과를 전달하는 dto</br>
│ │ ├── MovingRequestDto.java : 사용자가 입력한 이동을 전달하는 dto</br>
│ │ └── PlayCountResponseDto.java : 총 게임 횟수를 전달하는 dto</br>
│ ├── service</br>
│ │ └── BridgeGame.java : 서비스 레이어의 역할을 하며 domain을 이용하여 서비스 로직을 담당하여 controller에게 넘겨주는 클래스 </br>
│ ├── util</br>
│ │ └── Validator.java : 유효성을 검증하는 메서드들을 모아놓은 클래스</br>
│ └── view</br>
│ ├── InputView.java : 사용자의 입력을 받는 과정에 대한 view</br>
│ ├── OutputView.java : 사용자에게 결과를 출력하는 과정에 대한 view</br>
│ └── ViewConstant.java : view에 쓰이는 상수들을 모아놓은 클래스</br>

## 기능 구현 목록 정리

### 도메인 로직

- [x] 다리 길이가 3부터 20까지인지 유효성 검증을 한다.
    - [x] 다리 길이가 2 혹은 21인 경우를 검증한다.
    - [x] 다리 길이가 3 혹은 20인 경우를 검증한다.
- [x] 다리를 생성한다.
    - [x] 다리를 생성할 때 위 칸과 아래 칸 중 건널 수 있는 칸은 0과 1 중 무작위 값을 이용해서 정한다.
    - [x] 위 칸을 건널 수 있는 경우 U, 아래 칸을 건널 수 있는 경우 D값으로 나타낸다.
    - [x] 무작위 값이 0인 경우 아래 칸, 1인 경우 위 칸이 건널 수 있는 칸이 된다.
- 사용자가 입력한 이동할 칸에 대해 결과를 낸다.
- [x] 결과에 따라 출력할 다리 모양을 만든다.
    - [x] 이동할 수 있는 칸을 선택한 경우 O 표시
    - [x] 이동할 수 없는 칸을 선택한 경우 X 표시
    - [x] 선택하지 않은 칸은 공백 한 칸으로 표시
    - [x] 다리의 시작은 [, 다리의 끝은 ]으로 표시
    - [x] 다리 칸의 구분은 | (앞뒤 공백 포함) 문자열로 구분
    - [x] 현재까지 건넌 다리를 모두 출력
- [x] 건널 수 있는 칸을 선택한 경우
    - [x] 과정을 반복한다.
- [x] 건널 수 없는 칸을 선택한 경우
    - [x] 라운드를 종료한다.
- [x] 게임의 상태를 정한다.
    - [x] 끝까지 간 경우 성공
    - [x] 끝까지 가지 못한 경우 실패
- [x] 재시작 여부가 "Q"가 아니라면 같은 다리에 대해 과정을 반복한다.
- [x] 총 시도한 횟수를 계산한다.

### 어플리케이션 서비스 로직

- [x] 게임 시작 안내를 출력한다.
- [x] 다리 길이의 입력을 안내한다.
- [x] 다리 길이를 입력 받는다.
    - [x] 다리 길이가 숫자인지 유효성 검증을 한다.
- [x] 이동할 칸의 입력을 안내한다.
- [x] 이동할 칸을 입력 받는다.
    - [x] "U"와 "D"인지 유효성 검증을 한다.
- [x] 이동의 결과를 안내한다.
- [x] 게임을 다시 시도할지 여부를 입력 받는다.
    - [x] "R"과 "Q"인지 유효성 검증을 한다.
- [x] 최종 게임 결과를 안내한다.
- [x] 게임 성공 여부를 안내한다.
- [x] 총 시도한 횟수를 안내받는다.

## 게임 진행 과정

1. 게임 시작 안내를 출력한다.
2. 다리의 길이를 입력한다.
    - 다리 길이는 3부터 20까지의 숫자이다.
    - 숫자가 아닌 입력 예외 처리
    - 숫자이지만 범위가 다른 예외 처리
3. 다리를 생성한다.
    - 다리를 생성할 때 위 칸과 아래 칸 중 건널 수 있는 칸은 0과 1 중 무작위 값을 이용해서 정한다.
    - 위 칸을 건널 수 있는 경우 U, 아래 칸을 건널 수 있는 경우 D값으로 나타낸다.
    - 무작위 값이 0인 경우 아래 칸, 1인 경우 위 칸이 건널 수 있는 칸이 된다.
4. 이동할 칸을 입력한다.
    - "U"와 "D"로 위와 아래를 선택한다.
    - 나머지 입력은 예외처리한다.
5. 이동의 결과를 안내받는다.
    - 이동할 수 있는 칸을 선택한 경우 O 표시
    - 이동할 수 없는 칸을 선택한 경우 X 표시
    - 선택하지 않은 칸은 공백 한 칸으로 표시
    - 다리의 시작은 [, 다리의 끝은 ]으로 표시
    - 다리 칸의 구분은 | (앞뒤 공백 포함) 문자열로 구분
    - 현재까지 건넌 다리를 모두 출력
6.
    1. 건널 수 있는 칸을 선택한 경우
        - 다리를 다 건너지 않은 경우, 다음 칸에 대하여 4.-5.의 과정을 반복한다.
        - 다리를 다 건넌 경우, 7.을 진행한다.
    2. 건널 수 없는 칸을 선택한 경우
        - 라운드를 종료한다.
        - 게임을 다시 시도할지 여부를 입력받는다.
            - "R"과 "Q"로 각각 재시작, 종료를 선택한다.
            - "R"을 선택할 시, 4.의 과정부터 다시 시작한다.
            - 다리는 같은 다리에 대하여 진행한다.
7. 게임 성공 여부를 안내받는다.
8. 총 시도한 횟수를 안내받는다.

## 주요 요구 사항

- 사용자가 잘못된 값을 입력할 경우 IllegalArgumentException를 발생시키고, "[ERROR]"로 시작하는 에러 메시지를 출력 후 그 부분부터 입력을 다시 받는다.
- Exception이 아닌 IllegalArgumentException, IllegalStateException 등과 같은 명확한 유형을 처리한다.
- 프로그래밍 요구 사항에서 달리 명시하지 않는 한 파일, 패키지 이름을 수정하거나 이동하지 않는다.
- indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
- 도메인 로직에 단위 테스트를 구현해야 한다. 단, UI(System.out, System.in, Scanner) 로직은 제외한다.
- 메서드의 파라미터 개수는 최대 3개까지만 허용한다.
- 함수(또는 메서드)의 길이가 10라인을 넘어가지 않도록 구현한다.
- InputView
    - 패키지 변경 가능
    - 메서드 시그니처와 반환 타입 변경 가능
    - 메서드 추가 가능
    - InputView 클래스에서만 camp.nextstep.edu.missionutils.Console 의 readLine() 메서드를 이용해 사용자의 입력을 받을 수 있다.
- OutputView
    - 패키지 변경 가능
    - **메서드 이름 변경 불가**
    - 파라미터, 반환 타입 추가 변경 가능
    - 메서드 추가 가능
- BridgeGame
    - 필드 추가 가능
    - 패키지 변경 가능
    - **메서드 이름 변경 불가**
    - 파라미터, 반환 타입 추가 변경 가능
    - 메서드 추가, 변경 가능
- BridgeMaker
    - **필드 변경 불가**
    - **메서드 시그니처 반환 타입 변경 불가**
- BridgeRandomNumberGenerator
    - Random 값 추출은 제공된 bridge.BridgeRandomNumberGenerator의 generate()를 활용
    - **BridgeRandomNumberGenerator, BridgeNumberGenerator 클래스의 코드는 변경 불가**

## 체크리스트

[o] 요구사항을 정확히 준수하였는가?</br>
[o] 추가적인 예외를 고려하였는가?</br>
[o] 메소드가 하나의 기능만 하는가?</br>
[△] 한 메소드에 오직 한 단계의 인덴트만 허용했는가? => 두개의 인덴트까지 허용</br>
[o] 메소드 10줄 안 넘는가?</br>
[o] else 쓰지 않았는가?</br>
[o] 원시값과 문자열 포장했는가?</br>
[o] 콜렉션에 대해 일급 콜렉션을 적용했는가?</br>
[o] 3개 이상의 인스턴스 변수를 가진 클래스를 구현하지는 않았는가?</br>
[o] 메소드 이름이 적절한가? 동사와 전치사로 시작하는가?</br>
[o] 변수의 이름이 적절한가? 명사인가?</br>
[o] 메소드와 변수의 이름을 축약하지는 않았는가? 중복하지는 않았는가?</br>
[o] 커밋 메시지가 적절한가? 의미는 명확한가?</br>
[o] 매직넘버를 상수로 선언했는가?</br>
[△] getter/setter가 없이 구현했는가? => bridgeSize나 brige와 같이 필수인 곳을 제외하고는 최대한 사용을 줄임</br>
[o] 하나의 소스 파일에 하나의 클래스만 있는가?</br>
[o] 클래스를 작게 유지하기 위해 노력했는가?</br>
[o] import에 와일드 카드(*)가 없는가?</br>
[o] 패키지 선언 후와 메소드들의 사이에 빈 줄을 넣었는가?</br>
[o] 공백도 컨벤션을 준수했는가? 공백 라인을 의미있게 사용했는가?</br>
[o] 의미 없는 주석은 없는가?</br>
[o] Java가 제공하는 API를 적극 활용했는가?</br>
[o] 배열 대신 Java Collection을 사용했는가?</br>
[o] 정리한 기능 목록마다 정상 동작함을 테스트 코드로 확인하였는가?</br>
[o] PR 이름 제대로 했는가?</br>
[o] 출력 형식 제대로 했는가?</br>
[o] 불필요한 멤버 변수는 없는가?</br>
[o] 테스트코드의 리팩터링을 했는가?</br>
[o] 파라미터의 값만 바뀌는 테스트코드에서 @valueSource를 사용했는가?</br>
[o] final 값을 적절히 사용했는가?</br>
[o] 인스턴스 변수의 접근 제한을 private으로 했는가?</br>
[o] 단위테스트하기 어려운 코드를 적절히 리팩터링 했는가?</br>
[o] view가 domain을 모르는가?</br>
[o] domain이 view를 모르는가?</br>
[o] controller가 domain을 모르는가?</br>
[o] view와 domain 사이에 dto만 주고 받는가?</br>
[o] controller와 service가 dto를 통해 값을 주고 받는가?</br>
[o] service가 view를 모르는가?</br>
[o] dto가 service에서 변환되고 있는가? (controllers는 dto를 주고 받는 역할만 하고 있는가?, 즉 서비스 로직이 컨트롤러에 포함되어있지는 않은가?)</br>