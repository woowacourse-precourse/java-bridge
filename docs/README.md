# 기능목록

### Application

- [x] 게임 시작 문구 출력
- [x] 게임 진행
- [x] 게임 종료 문구 출력
- [x] 클래스 객체 생성, 의존성 주입

### InputView

- [x] bridge size 입력
    - [x]  예외상황
    - [x] 숫자가 아닌 경우
    - [x] 3~20 이 아닌 경우
- [x] 이동 명령 입력
    - [x] 예외상황
    - [x] [x] U,D 외의 다른 입력을 받는 경우
- [x] 재시도 여부 입력
    - [x] 예외상황
    - [x] R,Q 외의 다른 입력을 받는 경우
- [x] 예외 발생 시
    - [x] "[ERROR]"로 시작하는 에러 메시지를 출력한다.
    - [x] 그 부분부터 입력을 다시 받는다.

### OutputView

- 현재까지 이동한 다리의 상태 출력
  - [x] 형식 문자들 : [,|,]
  - [x] 사용자의 입력에 따른 O, X 위치
  - [x] 정답,¬ 구분하기
  - [x] **+** Upper, Lower 분리하여 출력하기
- 게임의 최종 결과 출력
  - [x] 최종 다리 그림 출력
  - [x] 최종 게임결과(성공여부, 시도횟수) 출력

### BridgeGame
- play : 1회 플레이 시작, 게임 성공여부 반환
- move
    - [x] 사용자로부터 U/D 입력받는다
    - [x] 다리를 출력한다.
    - [x] 정답 여부 반환한다.
- retry
    - [x] Q/R 입력받는다.
    - [x] 재시도 여부를 반환한다.

### 프로그래밍 요구 사항

- [x] indent depth <= 3
- [ ] 메서드 분리
- [x] else 금지
- [ ] 단위 테스트
- [x] 함수 길이 <= 10
- [x] BridgeGame 클래스에서 InputView, OutputView 를 사용하지 않는다.

# 소감

처음에는 문제가 어렵지 않아 보였으나, 생각보다 많은 어려움을 겪었습니다. 덕분에 더 성장하고 배울 수 있었던 기회였습니다.

1. 테스트 코드 작성하기

   콘솔 입력이나 랜덤값 등이 포함된 메서드는 테스트가 어려웠습니다. 그래서 테스트하기 좋은 구조를 만들기 위해 고민했고,
   메서드를 분리하는 과정에서 테스트하기 어려운 요소들을 따로 분리하고, 테스하기 좋은 요소들을 모아놓으려고 노력했습니다.
   또 ParameterizedTest와 같은 새로운 도구를 사용하여 테스트코드를 개선할 수 있었습니다.

2. 클래스의 역할 구분하기

   특히 BrigeGame과 Application의 역할을 구분하는 것이 어려웠습니다.
   처음에는 게임과 관련된 모든 기능(게임 시작, 1회 시도, 1회 움직이기, 재시도하기, 게임 종료 및 결과출력)을 BrigeGame이 담당해야 한다고 생각했습니다.
   하지만 그럴 경우 Application이 필요한 이유가 없다는 생각이 들었습니다.
   결국 처음 제공된 구조대로 (게임 시작, 1회 시도, 게임 종료, 각 클래스 생성) 은 Application이 담당하고, (1회 움직이기, 재시도하기)는 BrigeGame가 담당하도록 설계했습니다.
   이러한 설계 또한 Application 클래스의 역할이 분명하지 않아 개선이 필요하다고 생각합니다.
   Application 클래스가 어떤 역할을 해야 하는지 좀더 고민이 필요할 것 같습니다.

3. enum 적용하기

   U,D 대신 지난 과제에서 사용했던 enum을 적용해 보려 했으나, 불필요하게 코드가 복잡해져 다시 String 타입으로 돌아왔습니다. 하지만 객체지향의 원칙을 고려했을 때, Enum을 사용하는 것이 더 좋았을 것 같습니다.