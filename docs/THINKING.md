## 피드백 정리
#### 1. 비즈니스 로직과 UI 로직을 분리하자
하나의 클래스에 비즈니스 로직과 UI 로직이 동시에 존재하지 않도록 하자
단일 책임 원칙을 따르기 위함이다.
#### 2. 연관성 있는 상수는 static final 대신 enum을 활용하자
#### 3. final 키워드를 통해 값의 변경을 막자
#### 4. 객체의 상태 접근을 제어한다
이를 위해서 private를 사용하여 인스턴스 변수에 대한 접근을 막자.
#### 5. 객체는 객체답게 사용한다
말이 어렵지만, 객체 내부의 값을 getter를 통해 외부에서 사용해서 로직을 만들기 보단는 getter를 사용하지 말고 메시지를 보내 내부에서 로직을 진행할 수 있도록 해보자
`getter를 남용하게 되면 디미터의 법칙을 위반할 가능성이 생긴다`
#### 6. 필드의 수를 줄이기 위해 노력한다
필드의 수가 많은 것은 객체의 복잡도를 높이고, 버그 발생 가능성을 높일 수 있다.
이 피드백은 저번 Lotto에서 나의 컨트롤러를 확인해보면 굉장히 많은 필드가 생성되어 있다.
주의하자
#### 7. 테스트 코드도 코드다
테스트 코드도 코드이므로 리팩토링을 통해서 개선해 나가도록 하자.
반복적으로 수행하는 경우 중복되지 않게 개선할 필요가 있다.


## 생각 정리
### 이번의 경우 메소드의 길이가 10이 안넘어가도록 작성하고 리팩토링 하는 것에 집중해보자
**InputView와** **OutputView** 이 두개에서 입력과 출력을 담당해야 한다.
이외에는 출력과 입력에 관여하면 안된다.

**ENUM** 을 적극적으로 활용해보는 기회를 가져보도록 한다.
- 예외 문구에 대한 처리 활용
- 출력문에 대한 열거형 활용

**메소드의 길이가 10을 넘어가면 안된다**
- 이를 해결하기 위해서 메소드 내부의 기능을 여러개로 나누어줄 필요가 있다.
### 다리 출력
다리의 경우 **OutputView 클래스**에서 **printMap**에서 관리하고 있다.
허나 메소드의 길이가 길어지기 때문에 메소드를 분리했다.
**printTrue**의 경우 정답의 경우 어떻게 관리할지
**printFalse**의 경우 오답의 경우 어떻게 관리할지 한다.
첫번째 입력의 경우를 위해서 조건문을 만들어서 관리한다.
이외에 출력과 관련된 모든 것을 OutputView에서 관리하고 외부에서 상황에 따라서 호출할 수 있도록 해준다.
혹은 내부에서 사용할 수 있도록 매개변수를 넘겨주어 활용한다.

그렇다면 이에 대한 호출은 어디서 관리해야 할까
하나의 컨트롤러에서 처리하도록 한다.
- 컨트롤러에서 모두 처리하도록 하니 컨트롤러에서 주된 역할을 하는 메소드의 길이가 너무 길어지게 된다.
- 메소드 분리 혹은 클래스를 생성해서 나눠주도록 하자.

### 다리 생성
BridgeMaker 클래스에서 다리를 생성하는데 **makeBridge**로 0과 1로 입력받은 것을 **compareBridge**로 U와 D로 변환시키고 있다.
